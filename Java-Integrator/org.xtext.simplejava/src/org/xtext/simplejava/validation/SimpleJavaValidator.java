/*
 * generated by Xtext 2.25.0
 */
package org.xtext.simplejava.validation;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;

import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;
import org.xtext.simplejava.simpleJava.SimpleClass;
import org.xtext.simplejava.simpleJava.SimpleField;
import org.xtext.simplejava.simpleJava.SimpleJavaPackage;
import org.xtext.simplejava.simpleJava.SimpleMethod;
import org.xtext.simplejava.simpleJava.SimplePackage;
import org.xtext.simplejava.simpleJava.SimpleParam;

/**
 * This class contains custom validation rules.
 *
 * See
 * https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class SimpleJavaValidator extends AbstractSimpleJavaValidator {

	@Check
	public void checkForDuplicateSimpleFields(SimpleClass simpleClass) {

		EList<SimpleField> simpleFields = simpleClass.getSimpleFields();
		HashSet<String> names = new HashSet<>();

		for (SimpleField simpleField : simpleFields) {
			String name = simpleField.getName();

			if (!names.contains(name)) {
				names.add(name);
			} else {
				error("Duplicate field: " + name, SimpleJavaPackage.Literals.SIMPLE_CLASS__SIMPLE_FIELDS,
						simpleFields.indexOf(simpleField));
			}
		}
	}

	@Check
	public void checkForDuplicateSimpleClasses(SimplePackage simplePackage) {

		EList<SimpleClass> simpleClasses = simplePackage.getSimpleClasses();
		HashSet<String> names = new HashSet<>();

		for (SimpleClass simpleClass : simpleClasses) {
			String name = simpleClass.getName();

			if (!names.contains(name)) {
				names.add(name);
			} else {
				error("Duplicate class: " + name, SimpleJavaPackage.Literals.SIMPLE_PACKAGE__SIMPLE_CLASSES,
						simpleClasses.indexOf(simpleClass));
			}
		}
	}

	@Check
	public void checkForDuplicateMethods(SimpleClass simpleClass) {

		EList<SimpleMethod> simpleMethods = simpleClass.getSimpleMethods();
		HashMap<String, ArrayList<SimpleMethod>> names = new HashMap<>();

		for (SimpleMethod simpleMethod : simpleMethods) {
			String name = simpleMethod.getName();

			if (!names.containsKey(name)) {
				ArrayList<SimpleMethod> methods = new ArrayList<>();
				methods.add(simpleMethod);
				names.put(name, methods);
			} else {
				names.get(name).add(simpleMethod);
			}
		}

		for (ArrayList<SimpleMethod> methods : names.values()) {

			if (methods.size() == 1) {
				continue;
			}

			for (int i = 1; i < methods.size(); i++) {
				for (int j = 0; j < i; j++) {

					EList<SimpleParam> simpleParams1 = methods.get(i).getParams();
					EList<SimpleParam> simpleParams2 = methods.get(j).getParams();

					if (simpleParams1.size() != simpleParams2.size()) {
						continue;
					}
					if (simpleParams1.size() == 0 && simpleParams2.size() == 0) {
						error("Duplicate method: " + methods.get(i).getName(),
								SimpleJavaPackage.Literals.SIMPLE_CLASS__SIMPLE_METHODS,
								simpleMethods.indexOf(methods.get(i)));
					} else {
						for (int k = 0; k < simpleParams1.size(); k++) {
							if (!simpleParams1.get(k).getParamType().getType()
									.equals(simpleParams2.get(k).getParamType().getType())) {
								break;
							}
							if (simpleParams1.get(k).getParamType().getType().equals(
									simpleParams2.get(k).getParamType().getType()) && k == simpleParams1.size() - 1) {
								error("Duplicate method: " + methods.get(i).getName(),
										SimpleJavaPackage.Literals.SIMPLE_CLASS__SIMPLE_METHODS,
										simpleMethods.indexOf(methods.get(i)));
							}
						}
					}
				}
			}
		}

	}

//	@Check
//	public void checkIfInterface(SimpleClass simpleClass) {
//		EList<JvmParameterizedTypeReference> interfaces = simpleClass.getSimpleInterfaces();
//
//		for (JvmParameterizedTypeReference refType : interfaces) {
//			if(refType.getType() instanceof JvmGenericType) {
//				JvmGenericType type = (JvmGenericType) refType.getType();
//				if (!type.isInterface()) {
//					error("The referenced type is not an interface" + refType.getQualifiedName(),
//							SimpleJavaPackage.Literals.SIMPLE_CLASS__SIMPLE_INTERFACES, interfaces.indexOf(refType));
//				}
//			}
//			
//		}
//	}

}